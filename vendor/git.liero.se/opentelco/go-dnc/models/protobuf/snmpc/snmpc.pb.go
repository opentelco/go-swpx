// Code generated by protoc-gen-go. DO NOT EDIT.
// source: git.liero.se/opentelco/go-dnc/proto/snmpc.proto

package snmpc

import (
	fmt "fmt"
	metric "git.liero.se/opentelco/go-dnc/models/protobuf/metric"
	shared "git.liero.se/opentelco/go-dnc/models/protobuf/shared"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SnmpVersion int32

const (
	// First must be zero in proto3
	// not a valid option for SNMPC
	SnmpVersion_ZERO SnmpVersion = 0
	// Enum begins here.
	SnmpVersion_VERSION1  SnmpVersion = 1
	SnmpVersion_VERSION2c SnmpVersion = 2
	SnmpVersion_VERSION3  SnmpVersion = 3
)

var SnmpVersion_name = map[int32]string{
	0: "ZERO",
	1: "VERSION1",
	2: "VERSION2c",
	3: "VERSION3",
}

var SnmpVersion_value = map[string]int32{
	"ZERO":      0,
	"VERSION1":  1,
	"VERSION2c": 2,
	"VERSION3":  3,
}

func (x SnmpVersion) String() string {
	return proto.EnumName(SnmpVersion_name, int32(x))
}

func (SnmpVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0e6e9cce1d04ab20, []int{0}
}

type Type int32

const (
	Type_GET     Type = 0
	Type_SET     Type = 1
	Type_BULKGET Type = 2
	Type_WALK    Type = 3
)

var Type_name = map[int32]string{
	0: "GET",
	1: "SET",
	2: "BULKGET",
	3: "WALK",
}

var Type_value = map[string]int32{
	"GET":     0,
	"SET":     1,
	"BULKGET": 2,
	"WALK":    3,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0e6e9cce1d04ab20, []int{1}
}

type Config struct {
	Community            string             `protobuf:"bytes,1,opt,name=community,proto3" json:"community,omitempty"`
	Version              SnmpVersion        `protobuf:"varint,2,opt,name=version,proto3,enum=dnc.snmpc.SnmpVersion" json:"version,omitempty"`
	Port                 uint64             `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	Timeout              *duration.Duration `protobuf:"bytes,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Retries              int32              `protobuf:"varint,5,opt,name=retries,proto3" json:"retries,omitempty"`
	MaxIterations        int32              `protobuf:"varint,6,opt,name=max_iterations,json=maxIterations,proto3" json:"max_iterations,omitempty"`
	MaxRepetitions       int32              `protobuf:"varint,7,opt,name=max_repetitions,json=maxRepetitions,proto3" json:"max_repetitions,omitempty"`
	NonRepeaters         int32              `protobuf:"varint,8,opt,name=non_repeaters,json=nonRepeaters,proto3" json:"non_repeaters,omitempty"`
	DynamicRepititions   bool               `protobuf:"varint,9,opt,name=dynamic_repititions,json=dynamicRepititions,proto3" json:"dynamic_repititions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e6e9cce1d04ab20, []int{0}
}

func (m *Config) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Config.Unmarshal(m, b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Config.Marshal(b, m, deterministic)
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return xxx_messageInfo_Config.Size(m)
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetCommunity() string {
	if m != nil {
		return m.Community
	}
	return ""
}

func (m *Config) GetVersion() SnmpVersion {
	if m != nil {
		return m.Version
	}
	return SnmpVersion_ZERO
}

func (m *Config) GetPort() uint64 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Config) GetTimeout() *duration.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *Config) GetRetries() int32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

func (m *Config) GetMaxIterations() int32 {
	if m != nil {
		return m.MaxIterations
	}
	return 0
}

func (m *Config) GetMaxRepetitions() int32 {
	if m != nil {
		return m.MaxRepetitions
	}
	return 0
}

func (m *Config) GetNonRepeaters() int32 {
	if m != nil {
		return m.NonRepeaters
	}
	return 0
}

func (m *Config) GetDynamicRepititions() bool {
	if m != nil {
		return m.DynamicRepititions
	}
	return false
}

// Oid is item thack can be fetched through SNMP
type Oid struct {
	// Name of the Oid, SysDescr or something else, No translation is being done.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The actual OID, 1.2.3.4.5.6.6.6.33
	Oid string `protobuf:"bytes,2,opt,name=oid,proto3" json:"oid,omitempty"`
	// What kind of data is expected: string, int, bits, mac, ip...
	Type metric.MetricType `protobuf:"varint,3,opt,name=type,proto3,enum=dnc.metric.MetricType" json:"type,omitempty"`
	// Description of what is expected of the parser
	Help string `protobuf:"bytes,4,opt,name=help,proto3" json:"help,omitempty"`
	// Search the data and parse it, Regexp
	Lookup string `protobuf:"bytes,5,opt,name=lookup,proto3" json:"lookup,omitempty"`
	// the next two might be dropped. this is set in the config
	// True if the oid should be looked up with a repeater
	Repeater bool `protobuf:"varint,6,opt,name=repeater,proto3" json:"repeater,omitempty"`
	// reps is determined by this. If dyanmic a dynamic lookup is used
	// this dyanamic is done on ifIndex so it's not going to work for
	// some other OID group.
	//
	// Types that are valid to be assigned to Reps:
	//	*Oid_Dynamic
	//	*Oid_Number
	Reps                 isOid_Reps `protobuf_oneof:"reps"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Oid) Reset()         { *m = Oid{} }
func (m *Oid) String() string { return proto.CompactTextString(m) }
func (*Oid) ProtoMessage()    {}
func (*Oid) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e6e9cce1d04ab20, []int{1}
}

func (m *Oid) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Oid.Unmarshal(m, b)
}
func (m *Oid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Oid.Marshal(b, m, deterministic)
}
func (m *Oid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Oid.Merge(m, src)
}
func (m *Oid) XXX_Size() int {
	return xxx_messageInfo_Oid.Size(m)
}
func (m *Oid) XXX_DiscardUnknown() {
	xxx_messageInfo_Oid.DiscardUnknown(m)
}

var xxx_messageInfo_Oid proto.InternalMessageInfo

func (m *Oid) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Oid) GetOid() string {
	if m != nil {
		return m.Oid
	}
	return ""
}

func (m *Oid) GetType() metric.MetricType {
	if m != nil {
		return m.Type
	}
	return metric.MetricType_INT
}

func (m *Oid) GetHelp() string {
	if m != nil {
		return m.Help
	}
	return ""
}

func (m *Oid) GetLookup() string {
	if m != nil {
		return m.Lookup
	}
	return ""
}

func (m *Oid) GetRepeater() bool {
	if m != nil {
		return m.Repeater
	}
	return false
}

type isOid_Reps interface {
	isOid_Reps()
}

type Oid_Dynamic struct {
	Dynamic bool `protobuf:"varint,7,opt,name=dynamic,proto3,oneof"`
}

type Oid_Number struct {
	Number int64 `protobuf:"varint,8,opt,name=number,proto3,oneof"`
}

func (*Oid_Dynamic) isOid_Reps() {}

func (*Oid_Number) isOid_Reps() {}

func (m *Oid) GetReps() isOid_Reps {
	if m != nil {
		return m.Reps
	}
	return nil
}

func (m *Oid) GetDynamic() bool {
	if x, ok := m.GetReps().(*Oid_Dynamic); ok {
		return x.Dynamic
	}
	return false
}

func (m *Oid) GetNumber() int64 {
	if x, ok := m.GetReps().(*Oid_Number); ok {
		return x.Number
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Oid) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Oid_Dynamic)(nil),
		(*Oid_Number)(nil),
	}
}

type Task struct {
	// Unique ID of the task
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Track the status of the Task
	Status shared.Status `protobuf:"varint,2,opt,name=status,proto3,enum=dnc.shared.Status" json:"status,omitempty"`
	// if type is BulkGet all oids will be fetched bulked in one request
	Type Type `protobuf:"varint,3,opt,name=type,proto3,enum=dnc.snmpc.Type" json:"type,omitempty"`
	// Oids to fetch and process
	Oids []*Oid `protobuf:"bytes,4,rep,name=oids,proto3" json:"oids,omitempty"`
	// When fetched the Oids becomes metrics
	Metrics []*metric.Metric `protobuf:"bytes,5,rep,name=metrics,proto3" json:"metrics,omitempty"`
	// Configuration for SNMP-Client
	Config *Config             `protobuf:"bytes,6,opt,name=config,proto3" json:"config,omitempty"`
	Tags   map[string]*any.Any `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Set when the Task is created
	Created *timestamp.Timestamp `protobuf:"bytes,8,opt,name=created,proto3" json:"created,omitempty"`
	// Set when the progress of fetching it starts
	Started *timestamp.Timestamp `protobuf:"bytes,9,opt,name=started,proto3" json:"started,omitempty"`
	// Sets when DNC has fetched and parsed the data
	Completed *timestamp.Timestamp `protobuf:"bytes,10,opt,name=completed,proto3" json:"completed,omitempty"`
	// A difference between started and completed in MS
	ExecutionTime        *duration.Duration `protobuf:"bytes,11,opt,name=execution_time,json=executionTime,proto3" json:"execution_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_0e6e9cce1d04ab20, []int{2}
}

func (m *Task) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Task.Unmarshal(m, b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Task.Marshal(b, m, deterministic)
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return xxx_messageInfo_Task.Size(m)
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

func (m *Task) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Task) GetStatus() shared.Status {
	if m != nil {
		return m.Status
	}
	return shared.Status_NEW
}

func (m *Task) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_GET
}

func (m *Task) GetOids() []*Oid {
	if m != nil {
		return m.Oids
	}
	return nil
}

func (m *Task) GetMetrics() []*metric.Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Task) GetConfig() *Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Task) GetTags() map[string]*any.Any {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Task) GetCreated() *timestamp.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *Task) GetStarted() *timestamp.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *Task) GetCompleted() *timestamp.Timestamp {
	if m != nil {
		return m.Completed
	}
	return nil
}

func (m *Task) GetExecutionTime() *duration.Duration {
	if m != nil {
		return m.ExecutionTime
	}
	return nil
}

func init() {
	proto.RegisterEnum("dnc.snmpc.SnmpVersion", SnmpVersion_name, SnmpVersion_value)
	proto.RegisterEnum("dnc.snmpc.Type", Type_name, Type_value)
	proto.RegisterType((*Config)(nil), "dnc.snmpc.Config")
	proto.RegisterType((*Oid)(nil), "dnc.snmpc.Oid")
	proto.RegisterType((*Task)(nil), "dnc.snmpc.Task")
	proto.RegisterMapType((map[string]*any.Any)(nil), "dnc.snmpc.Task.TagsEntry")
}

func init() {
	proto.RegisterFile("git.liero.se/opentelco/go-dnc/proto/snmpc.proto", fileDescriptor_0e6e9cce1d04ab20)
}

var fileDescriptor_0e6e9cce1d04ab20 = []byte{
	// 786 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0x51, 0x8f, 0xdb, 0x44,
	0x10, 0xc7, 0xcf, 0xb1, 0xcf, 0x8e, 0xc7, 0xbd, 0xd4, 0x0c, 0xa8, 0x72, 0x23, 0x04, 0xd1, 0x55,
	0x88, 0x70, 0xa2, 0x76, 0xc9, 0x81, 0x54, 0xf1, 0x44, 0x0f, 0x22, 0x5a, 0xb5, 0xe5, 0xa4, 0xbd,
	0x50, 0xa4, 0xbe, 0x54, 0x7b, 0xf6, 0x36, 0x5d, 0x9d, 0xbd, 0x6b, 0x79, 0xd7, 0xd5, 0xe5, 0x2b,
	0xf2, 0x1d, 0x78, 0xe0, 0x9b, 0xa0, 0x5d, 0xdb, 0x49, 0xe8, 0x49, 0x1c, 0x7d, 0xca, 0xec, 0xcc,
	0x6f, 0x46, 0x9e, 0x7f, 0xfe, 0xbb, 0x90, 0xad, 0xb9, 0x4e, 0x4b, 0xce, 0x1a, 0x99, 0x2a, 0x96,
	0xc9, 0x9a, 0x09, 0xcd, 0xca, 0x5c, 0x66, 0x6b, 0xf9, 0xb0, 0x10, 0x79, 0x56, 0x37, 0x52, 0xcb,
	0x4c, 0x89, 0xaa, 0xce, 0x53, 0x1b, 0x63, 0x58, 0x88, 0x3c, 0xb5, 0x89, 0xe9, 0x17, 0x6b, 0x29,
	0xd7, 0x25, 0xeb, 0xa0, 0xcb, 0xf6, 0x6d, 0x56, 0xb4, 0x0d, 0xd5, 0x5c, 0x8a, 0x0e, 0x9d, 0x7e,
	0xf9, 0x61, 0x5d, 0xf3, 0x8a, 0x29, 0x4d, 0xab, 0xba, 0x07, 0xee, 0x7f, 0x08, 0x50, 0xb1, 0xe9,
	0x4b, 0x8f, 0xfe, 0xcf, 0x77, 0x55, 0x4c, 0x37, 0x3c, 0xff, 0x98, 0x0e, 0xf5, 0x8e, 0x36, 0xac,
	0xe8, 0x3a, 0x8e, 0xff, 0x1e, 0x81, 0xff, 0xb3, 0x14, 0x6f, 0xf9, 0x1a, 0x3f, 0x87, 0x30, 0x97,
	0x55, 0xd5, 0x0a, 0xae, 0x37, 0x89, 0x33, 0x73, 0xe6, 0x21, 0xd9, 0x25, 0xf0, 0x11, 0x04, 0xef,
	0x59, 0xa3, 0xb8, 0x14, 0xc9, 0x68, 0xe6, 0xcc, 0x27, 0x8b, 0x7b, 0xe9, 0x56, 0x85, 0xf4, 0x42,
	0x54, 0xf5, 0xab, 0xae, 0x4a, 0x06, 0x0c, 0x11, 0xbc, 0x5a, 0x36, 0x3a, 0x71, 0x67, 0xce, 0xdc,
	0x23, 0x36, 0xc6, 0x53, 0x08, 0x8c, 0x00, 0xb2, 0xd5, 0x89, 0x37, 0x73, 0xe6, 0xd1, 0xe2, 0x7e,
	0xda, 0xed, 0x9f, 0x0e, 0xfb, 0xa7, 0xbf, 0xf4, 0x02, 0x92, 0x81, 0xc4, 0x04, 0x82, 0xc6, 0x6c,
	0xc9, 0x54, 0x72, 0x38, 0x73, 0xe6, 0x87, 0x64, 0x38, 0xe2, 0x57, 0x30, 0xa9, 0xe8, 0xf5, 0x1b,
	0xae, 0x59, 0xd7, 0xa3, 0x12, 0xdf, 0x02, 0x47, 0x15, 0xbd, 0x7e, 0xb6, 0x4d, 0xe2, 0xd7, 0x70,
	0xd7, 0x60, 0x0d, 0xab, 0x99, 0xe6, 0x1d, 0x17, 0x58, 0xce, 0x74, 0x93, 0x5d, 0x16, 0x1f, 0xc0,
	0x91, 0x90, 0xc2, 0x82, 0x54, 0xb3, 0x46, 0x25, 0x63, 0x8b, 0xdd, 0x11, 0x52, 0x90, 0x21, 0x87,
	0x19, 0x7c, 0x5a, 0x6c, 0x04, 0xad, 0x78, 0x6e, 0x40, 0x3e, 0x4c, 0x0c, 0x67, 0xce, 0x7c, 0x4c,
	0xb0, 0x2f, 0x91, 0x5d, 0xe5, 0xf8, 0x2f, 0x07, 0xdc, 0x73, 0x5e, 0x18, 0x41, 0x04, 0xad, 0x58,
	0xaf, 0xad, 0x8d, 0x31, 0x06, 0x57, 0xf2, 0xc2, 0x4a, 0x1a, 0x12, 0x13, 0xe2, 0x09, 0x78, 0x7a,
	0x53, 0x33, 0x2b, 0xdb, 0xa0, 0x72, 0xff, 0x27, 0xbf, 0xb4, 0x3f, 0xab, 0x4d, 0xcd, 0x88, 0x65,
	0xcc, 0xc4, 0x77, 0xac, 0xac, 0xad, 0x96, 0x21, 0xb1, 0x31, 0xde, 0x03, 0xbf, 0x94, 0xf2, 0xaa,
	0xad, 0xad, 0x58, 0x21, 0xe9, 0x4f, 0x38, 0x85, 0xf1, 0xb0, 0x97, 0x55, 0x69, 0x4c, 0xb6, 0x67,
	0x9c, 0x42, 0xd0, 0x7f, 0xb7, 0x15, 0x66, 0xfc, 0xf4, 0x80, 0x0c, 0x09, 0x4c, 0xc0, 0x17, 0x6d,
	0x75, 0xc9, 0x1a, 0x2b, 0x86, 0xfb, 0xf4, 0x80, 0xf4, 0xe7, 0x33, 0x1f, 0xbc, 0x86, 0xd5, 0xea,
	0xf8, 0x4f, 0x0f, 0xbc, 0x15, 0x55, 0x57, 0x38, 0x81, 0x11, 0x2f, 0xfa, 0xf5, 0x46, 0x76, 0x15,
	0x5f, 0x69, 0xaa, 0x5b, 0xd5, 0x5b, 0x06, 0x3b, 0xcb, 0x74, 0xfe, 0xbb, 0xb0, 0x15, 0xd2, 0x13,
	0xf8, 0xe0, 0x5f, 0x6b, 0xdf, 0xdd, 0x33, 0xd7, 0xde, 0xbe, 0xc7, 0xe0, 0x49, 0x5e, 0xa8, 0xc4,
	0x9b, 0xb9, 0xf3, 0x68, 0x31, 0xd9, 0x83, 0xce, 0x79, 0x41, 0x6c, 0x0d, 0xbf, 0x85, 0xa0, 0x93,
	0xcb, 0xb8, 0xc5, 0x60, 0x78, 0x53, 0x42, 0x32, 0x20, 0xf8, 0x0d, 0xf8, 0xb9, 0xb5, 0xbf, 0xd5,
	0x24, 0x5a, 0x7c, 0xb2, 0x37, 0xb3, 0xbb, 0x17, 0xa4, 0x07, 0xf0, 0x21, 0x78, 0x9a, 0xae, 0x8d,
	0x75, 0x5c, 0x6b, 0xdc, 0xbd, 0x2f, 0xa4, 0xea, 0x2a, 0x5d, 0xd1, 0xb5, 0x5a, 0x0a, 0xdd, 0x6c,
	0x88, 0xc5, 0xf0, 0x7b, 0x08, 0xf2, 0xc6, 0xc8, 0x5b, 0x58, 0xe1, 0xa2, 0xc5, 0xf4, 0x86, 0xd5,
	0x57, 0xc3, 0x5b, 0x40, 0x06, 0xd4, 0x74, 0x29, 0x4d, 0x1b, 0xd3, 0x15, 0xde, 0xde, 0xd5, 0xa3,
	0xf8, 0xd8, 0x5e, 0xdd, 0xba, 0x64, 0xa6, 0x0f, 0x6e, 0xed, 0xdb, 0xc1, 0xf8, 0x13, 0x4c, 0xd8,
	0x35, 0xcb, 0x5b, 0xe3, 0xd4, 0x37, 0xe6, 0xc2, 0x25, 0xd1, 0x6d, 0xf7, 0xf2, 0x68, 0xdb, 0x60,
	0x26, 0x4e, 0x5f, 0x42, 0xb8, 0x5d, 0xdd, 0xd8, 0xf9, 0x8a, 0x0d, 0xaf, 0x87, 0x09, 0xf1, 0x04,
	0x0e, 0xdf, 0xd3, 0xb2, 0x65, 0xd6, 0x02, 0xd1, 0xe2, 0xb3, 0x1b, 0x73, 0x9f, 0x88, 0x0d, 0xe9,
	0x90, 0x1f, 0x47, 0x8f, 0x9d, 0x93, 0x33, 0x88, 0xf6, 0x5e, 0x13, 0x1c, 0x83, 0xf7, 0x7a, 0x49,
	0xce, 0xe3, 0x03, 0xbc, 0x03, 0xe3, 0x57, 0x4b, 0x72, 0xf1, 0xec, 0xfc, 0xb7, 0xef, 0x62, 0x07,
	0x8f, 0x20, 0xec, 0x4f, 0x8b, 0x3c, 0x1e, 0xed, 0x15, 0x4f, 0x63, 0xf7, 0x24, 0x03, 0xcf, 0x98,
	0x06, 0x03, 0x70, 0x7f, 0x5d, 0xae, 0xe2, 0x03, 0x13, 0x5c, 0x2c, 0x57, 0xb1, 0x83, 0x11, 0x04,
	0x67, 0xbf, 0xbf, 0x78, 0x6e, 0xb2, 0x23, 0x33, 0xfb, 0x8f, 0x27, 0x2f, 0x9e, 0xc7, 0xee, 0xd9,
	0x0f, 0xaf, 0x4f, 0xff, 0xfb, 0xe5, 0xac, 0x64, 0xc1, 0x4a, 0xb5, 0x7b, 0xa4, 0xed, 0xff, 0x7e,
	0xe9, 0xdb, 0xf3, 0xe9, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xae, 0xbc, 0xb2, 0x92, 0x41, 0x06,
	0x00, 0x00,
}
