/*
 * Copyright (c) 2023. Liero AB
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

syntax = "proto3";

option go_package = "git.liero.se/opentelco/go-swpx/proto/go/fleet/schedulepb";

import "fleet_common.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";

package fleet.schdeule;

service DeviceService {
    // Get a schedyle by its id, return a Schedule
    rpc GetByID(GetByIDParameters) returns (Schedule) {}

    // Get a device by its hostname, managment ip or serial number etc (used to search for a device)
    rpc List(ListParameters) returns (ListResponse) {}

    // Create a new schedule
    rpc Create(CreateParameters) returns (Schedule) {}

    // Update a schedul, set it to active or inactive etc
    rpc Update(UpdateParameters) returns (Schedule) {}

    // Assign a schedule to a device by cloing the selected schedule and assigning it to the device
    rpc Assign(AssignParameters) returns (Schedule) {}

    rpc Delete(DeleteParameters) returns (google.protobuf.Empty) {}
}

message Schedule {
    // the id of the schedule
    string id = 1;

    // name of the schedule
    string name = 2;

    // description, what the schedule does etc e.g "Collect device data every 5 minutes"
    string description = 3;

    // the id of the device the schedule is for, if the id is nil the schedule is a template that can
    // be used to attach to a device
    string device_id = 4;

    // duration between each poll
    // minimum of 120 seconds (2 minutes)
    google.protobuf.Duration interval = 5;

    enum Type {
        SCHEDULE_TYPE_NOT_SET = 0;
        COLLECT_DEVICE        = 1;
        COLLECT_CONFIG        = 2;
    }

    // the type of schedule
    Type type = 6;

    // the last time the schedule was run (if it has been run)
    google.protobuf.Timestamp last_run = 7;

    // if the schedule is active or not (if it should be run)
    // only applies to schedules that are attached to a device
    bool active = 8;

    // the number of times the schedule has failed to run
    // if the schedule has failed more than 3 times it will be disabled. To unlock
    // the schedule it needs to be manually enabled again and setting failed count to 0
    int64 failed_count = 9;

    // when the schedule was created
    google.protobuf.Timestamp created_at = 10;

    // when the schedule was last updated
    google.protobuf.Timestamp updated_at = 11;
}

message GetByIDParameters {
    // id of the schedule to get
    string id = 1;
}

message ListParameters {
    // the id of the device to list schedules for
    optional string device_id = 1;

    // the type of schedule to list
    optional Schedule.Type type = 2;

    enum Filter {
        FILTER_NOT_SET  = 0;
        FILTER_ACTIVE   = 1;
        FILTER_INACTIVE = 2;
    }
    repeated Filter filter = 3;

    // has schedule to be run in the next 10 secs, the device also needs to be in the active state
    // or it will not be returned (default false)
    optional bool has_firing_schedule = 4;

    enum OrderBy {
        ORDER_BY_NOT_SET = 0;
        ORDER_BY_CREATED = 1;
        ORDER_BY_UPDATED = 2;
    }
    repeated OrderBy order_by = 6;

    // order descending is the default
    optional bool order_asc = 7;

    // how many notifications to return (default 10)
    optional int64 limit = 8;

    // offset to start from (default 0)
    optional int64 offset = 9;
}

message ListResponse {
    repeated Schedule schedules     = 1;
    fleet.common.PageInfo page_info = 2;
}

message CreateParameters {
    // name of the schedule
    string name = 1;

    // description, what the schedule does etc e.g "Collect device data every 5 minutes"
    optional string description = 2;

    // duration between each poll
    // minimum of 120 seconds (2 minutes)
    google.protobuf.Duration interval = 3;

    enum Type {
        SCHEDULE_TYPE_NOT_SET = 0;
        COLLECT_DEVICE        = 1;
        COLLECT_CONFIG        = 2;
    }

    // the type of schedule
    Type type = 4;
}

message AssignParameters {
    // the id of the schedule to assign
    string schedule_id = 1;

    // the id of the device to assign the schedule to
    string device_id = 2;

    // if the schedule should be active or not, default is active
    bool assign_as_inactive = 3;
}


message DeleteParameters {
    // the id of the schedule to delete
    string schedule_id = 1;
}

message UpdateParameters {
    // the id of the schedule to update
    string schedule_id = 1;

    // name of the schedule
    optional string name = 2;

    // description, what the schedule does etc e.g "Collect device data every 5 minutes"
    optional string description = 3;

    // duration between each poll
    // minimum of 120 seconds (2 minutes)
    optional google.protobuf.Duration interval = 4;

    enum Type {
        SCHEDULE_TYPE_NOT_SET = 0;
        COLLECT_DEVICE        = 1;
        COLLECT_CONFIG        = 2;
    }

    // the type of schedule
    optional Type type = 5;

    // if the schedule should be active or not
    optional bool active = 6;
}

enum TaskQueue {
    TASK_QUEUE_FLEET_SCHEDULES = 0;
}
